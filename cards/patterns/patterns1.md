Here is a set of flashcards covering common Gang of Four (GoF) design patterns, formatted as per your specifications. The set includes both standard and multiple-choice flashcards, complete with relevant links for further reading.

<!-- Card Start -->
### Front
Singleton Pattern

### Back
Ensures that a class has only one instance and provides a global point of access to it.

[Learn more about the Singleton Pattern](https://refactoring.guru/design-patterns/singleton)

<!-- Card End --> <!-- Card Start -->
### Front
Factory Method Pattern

### Back
Defines an interface for creating an object, but allows subclasses to alter the type of objects that will be created.

[Learn more about the Factory Method Pattern](https://refactoring.guru/design-patterns/factory-method)

<!-- Card End --> <!-- Card Start -->
### Front
Abstract Factory Pattern

### Back
Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

[Learn more about the Abstract Factory Pattern](https://refactoring.guru/design-patterns/abstract-factory)

<!-- Card End --> <!-- Card Start -->
### Front
Builder Pattern

### Back
Separates the construction of a complex object from its representation, allowing the same construction process to create various representations.

[Learn more about the Builder Pattern](https://refactoring.guru/design-patterns/builder)

<!-- Card End --> <!-- Card Start -->
### Front
Prototype Pattern

### Back
Specifies the kinds of objects to create using a prototypical instance and creates new objects by copying this prototype.

[Learn more about the Prototype Pattern](https://refactoring.guru/design-patterns/prototype)

<!-- Card End --> <!-- Card Start -->
### Front
Adapter Pattern

### Back
Allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code.

[Learn more about the Adapter Pattern](https://refactoring.guru/design-patterns/adapter)

<!-- Card End --> <!-- Card Start -->
### Front
Bridge Pattern

### Back
Decouples an abstraction from its implementation so that the two can vary independently.

[Learn more about the Bridge Pattern](https://refactoring.guru/design-patterns/bridge)

<!-- Card End --> <!-- Card Start -->
### Front
Composite Pattern

### Back
Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions of objects uniformly.

[Learn more about the Composite Pattern](https://refactoring.guru/design-patterns/composite)

<!-- Card End --> <!-- Card Start -->
### Front
Decorator Pattern

### Back
Attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

[Learn more about the Decorator Pattern](https://refactoring.guru/design-patterns/decorator)

<!-- Card End --> <!-- Card Start -->
### Front
Facade Pattern

### Back
Provides a simplified interface to a larger body of code, such as a complex subsystem.

[Learn more about the Facade Pattern](https://refactoring.guru/design-patterns/facade)

<!-- Card End --> <!-- Card Start -->
### Front
Flyweight Pattern

### Back
Uses sharing to support large numbers of fine-grained objects efficiently.

[Learn more about the Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight)

<!-- Card End --> <!-- Card Start -->
### Front
Proxy Pattern

### Back
Provides a surrogate or placeholder for another object to control access to it.

[Learn more about the Proxy Pattern](https://refactoring.guru/design-patterns/proxy)

<!-- Card End --> <!-- Card Start -->
### Front
Chain of Responsibility Pattern

### Back
Passes a request along a chain of handlers. Each handler decides either to process the request or to pass it to the next handler in the chain.

[Learn more about the Chain of Responsibility Pattern](https://refactoring.guru/design-patterns/chain-of-responsibility)

<!-- Card End --> 
<!-- Card Start -->
### Front
Command Pattern

### Back
Encapsulates a request as an object, thereby allowing for parameterization of clients with different requests, queuing of requests, and logging of the requests.

[Learn more about the Command Pattern](https://refactoring.guru/design-patterns/command)

<!-- Card End --> <!-- Card Start -->
### Front
Interpreter Pattern

### Back
Given a language, defines a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.

[Learn more about the Interpreter Pattern](https://refactoring.guru/design-patterns/interpreter)

<!-- Card End --> <!-- Card Start -->
### Front
Iterator Pattern

### Back
Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

[Learn more about the Iterator Pattern](https://refactoring.guru/design-patterns/iterator)

<!-- Card End --> <!-- Card Start -->
### Front
Mediator Pattern

### Back
Defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other explicitly.

[Learn more about the Mediator Pattern](https://refactoring.guru/design-patterns/mediator)

<!-- Card End --> <!-- Card Start -->
### Front
Memento Pattern

### Back
Captures and externalizes an object's internal state so that the object can be restored to this state later without violating encapsulation.

[Learn more about the Memento Pattern](https://refactoring.guru/design-patterns/memento)

<!-- Card End --> <!-- Card Start -->
### Front
Observer Pattern

### Back
Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

[Learn more about the Observer Pattern](https://refactoring.guru/design-patterns/observer)

<!-- Card End --> <!-- Card Start -->
### Front
State Pattern

### Back
Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.

[Learn more about the State Pattern](https://refactoring.guru/design-patterns/state)

<!-- Card End --> <!-- Card Start -->
### Front
Strategy Pattern

### Back
Defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern lets the algorithm vary independently from clients that use it.

[Learn more about the Strategy Pattern](https://refactoring.guru/design-patterns/strategy)

<!-- Card End --> <!-- Card Start -->
### Front
Template Method Pattern

### Back
Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.

[Learn more about the Template Method Pattern](https://refactoring.guru/design-patterns/template-method)

<!-- Card End --> <!-- Card Start -->
### Front
Visitor Pattern

### Back
Represents an operation to be performed on the elements of an object structure. It allows you to define a new operation without changing the classes of the elements on which it operates.

[Learn more about the Visitor Pattern](https://refactoring.guru/design-patterns/visitor)

<!-- Card End --> <!-- Card Start -->
### Front
Model-View-Controller (MVC) Pattern

### Back
Separates an application into three main logical components: the Model, the View, and the Controller. Each component handles specific development aspects of an application.

[Learn more about the Model-View-Controller (MVC) Pattern](https://refactoring.guru/design-patterns/mvc)

<!-- Card End --> <!-- Card Start -->
### Front
Model-View-ViewModel (MVVM) Pattern

### Back
Facilitates a separation of development of the graphical user interface (the view) from the development of the business logic or ### Back-end logic (the model). The view model converts model information into values that can be displayed in a view.

[Learn more about the Model-View-ViewModel (MVVM) Pattern](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel)

<!-- Card End --> <!-- Card Start -->
### Front
Dependency Injection Pattern

### Back
A technique where one object supplies the dependencies of another object. It allows for loose coupling between components and improves testability and maintainability.

[Learn more about the Dependency Injection Pattern](https://en.wikipedia.org/wiki/Dependency_injection)

<!-- Card End --> <!-- Card Start -->
### Front
Service Locator Pattern

### Back
Encapsulates the processes involved in obtaining a service with a strong abstraction layer. This pattern uses a central registry known as the "service locator".

[Learn more about the Service Locator Pattern](https://en.wikipedia.org/wiki/Service_locator_pattern)

<!-- Card End --> <!-- Card Start -->
### Front
Repository Pattern

### Back
Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects.

[Learn more about the Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)

<!-- Card End --> <!-- Card Start -->
### Front
Unit of Work Pattern

### Back
Maintains a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems.

[Learn more about the Unit of Work Pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html)

<!-- Card End --> <!-- Card Start -->
### Front
Null Object Pattern

### Back
Provides an object as a surrogate for the lack of an object of a given type. Instead of using a null reference, it provides a relationship with an object that does nothing.

[Learn more about the Null Object Pattern](https://refactoring.guru/design-patterns/null-object)

<!-- Card End --> <!-- Card Start -->
### Front
Specification Pattern

### Back
A particular business rule that can be combined with other business rules. It allows you to encapsulate complex business logic in a reusable way.

[Learn more about the Specification Pattern](https://en.wikipedia.org/wiki/Specification_pattern)

<!-- Card End --> <!-- Card Start -->
### Front
Publish/Subscribe Pattern

### Back
A messaging pattern where senders of messages (publishers) do not program the messages to be sent directly to specific receivers (subscribers), but instead categorize published messages into classes without knowledge of which subscribers, if any, there may be.

[Learn more about the Publish/Subscribe Pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)

<!-- Card End --> <!-- Card Start -->
### Front
Lazy Loading Pattern

### Back
Defers initialization of an object until the point at which it is needed. It can contribute to efficiency in the program's operation if properly and appropriately used.

[Learn more about the Lazy Loading Pattern](https://martinfowler.com/eaaCatalog/lazyLoad.html)

<!-- Card End --> <!-- Card Start -->
### Front
Which pattern ensures a class has only one instance and provides a global point of access to it?

A: Factory Method

B: Singleton

C: Prototype

D: Builder

<!-- Card End -->





